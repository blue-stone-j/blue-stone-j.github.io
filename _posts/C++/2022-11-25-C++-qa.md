---
layout: post
title:  "C++使用中的QA"
date:   2022-11-20 08:30:00 +0800
categories: [Lan]
excerpt: 这篇文章整理了C++使用过程中遇到的问题以及对应的解决方案。
tags:
  - QA
  - C++
---

这篇文章整理了C++使用过程中遇到的问题以及对应的解决方案。这些方案并不总是能解决问题，只是提供一个排查问题的方向。覆盖范围包括编译、CMake、某些库使用中的问题，比如Eigen,PCL,yaml-cpp等等。



## 一、编译问题

##### 1. 

##### 2

```C++
collect2: error: ld returned 1 exit status
undefined reference to symbol '_ZN3tbb8internal25deallocate_via_handler_v3EPv'
```

在代码的前面部分出现了错误，导致此处引用错误，错误状态为1;导入库出错也可能导致这一结果。

##### 3.

##### 4

`std::bad_alloc`是 `operator new`不能满足内存分配请求时抛出的异常类型

##### 5

编译时出现如下错误

```C++
error: stray '\357' in program
```

原因分析：猜测，错误的原理是出现了不能识别的字符，例如了一个汉语的分号代替了英语的分号时

##### 6

编译时出现如下错误

```C++
error: cannot resolve overloaded function ‘getFitnessScore’ based on conversion to type ‘float’
```

原因分析：函数A调用函数B后，B的返回值为一个仅在函数B中有效的参数C，B为float型

##### 7

编译时出现如下错误

```C++
error: no match for call to ‘(Eigen::Matrix4f {aka Eigen::Matrix<float, 4, 4>}) ()’
```

原因分析：对于类型为Eigen::Matrix4f的东西，没有相匹配的可调用的东西。 <font color=Blue>？？？???</font>

##### 8

编译时出现如下错误

```C++
error: invalid new-expression of abstract class type ‘frame::G2oGraphOptimizer’
```

原因分析：类中存在需要实现的成员函数；基类中的虚函数，在子类中需要重载，但没有重载。

##### 9

编译时出现如下错误

```C++
error: “marked ‘override’, but does not override”
```

原因分析：重载虚函数时，函数的参数类型和名称需要相同，否则会出现上述错误

##### 10

编译时出现如下错误

```C++
uses undefined class
```

原因分析：main中引用了头文件A和B，B中引用了A。，会出现上述错误。

解决方案：删除main中A的引用

##### 11

编译时出现如下错误

```C++
error: usleep is not declared in this scope 
```
原因：没有包含该函数所在的头文件
解决方案：添加如下代码到出错的文件

```C++
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
```

##### 12. ??

编译时出现如下错误

```C++
cannot open shared object file: no such file or directory
```

解决方案：设置下环境变量可能会解决问题

##### 13

错误程序如下

```C++
Eigen::Vector3f pos(3,0);
```

编译时出现如下错误

```C++
expected identifier before numeric constant、
```

原因分析：重复定义了向量的维度

##### 14

编译时出现如下错误

```C++
expected unqualified-id before ‘if’ ; expected a declaration ; this declaration has no storage class or type specifier
```

原因分析：`if`语句应该放在函数内

##### 15

编译时出现如下警告

```C++
warning: ignoring #pragma omp parallel
```

原因分析：没有正确配置OpenMP(例如创建了相应的cmake文件来编译，但没有在CMakeLists文件中include该cmake文件)，直接在程序中使用了omp

##### 16

编译时出现如下错误

```C++
error: static assertion failed: YOU_MIXED_MATRICES_OF_DIFFERENT_SIZES
     #define EIGEN_STATIC_ASSERT(X,MSG) static_assert(X,#MSG)
```

原因分析： eigen定义的变量类型为matrix4d作为函数实参，在调用函数时，使用的形参为matrix3d

解决方案：使实参和形参的数据类型保持一致

##### 17

编译时出现如下错误

```C++
error: static assertion failed: YOU_MIXED_DIFFERENT_NUMERIC_TYPES__YOU_NEED_TO_USE_THE_CAST_METHOD_OF_MATRIXBASE_TO_CAST_NUMERIC_TYPES_EXPLICITLY
     #define EIGEN_STATIC_ASSERT(X,MSG) static_assert(X,#MSG);
```

原因分析：eigen变量赋值时，左右的数据类型不一致

解决方案：更改变量的数据类型，或者，使用强制转换

##### 18

编译时出现如下错误

```C++
/usr/include/boost/smart_ptr/shared_ptr.hpp:648: typename boost::detail::sp_member_access<T>::type boost::shared_ptr<T>::operator->() const [with T = pcl::PointCloud<pcl::PointXYZ>; typename boost::detail::sp_member_access<T>::type = pcl::PointCloud<pcl::PointXYZ>*]: Assertion `px != 0' failed.
```

原因分析如下  

```C++
pcl::PointCloud<pcl::PointXYZ>::Ptr keyPoses3D; // 在使用前没有new
```

解决方案如下

```C++
keyPoses3D.reset(new pcl::PointCloud<pcl::PointXYZ>());
```

##### 19

编译时出现如下错误

```C++
DSO missing from command line
```

原因分析：cmakelists其它正常，但 未加入需要的库(没有add target using `target_link_libraries`)

解决方案: 查看是否填写了库的路径以及库的路径是否正确

##### 20

编译时出现如下错误

```C++
invalid use of function
```

原因分析: 在默认构造函数完成后再执行自建的构造函数

解决方案: 除了构造以外的地方，不要调用构造函数

##### 21

```C++
lidarLocatorVec.push_back(LidarLocator(lidarsID[i]));
```

编译错误如下：

```C++
调用拷贝构造函数时提示use of deleted function错误：use of deleted function ‘LidarLocator::LidarLocator(LidarLocator&&)’
```

原因分析：声明移动构造函数证明你的类需要深拷贝，对于包含指针的类，编译器简单的浅拷贝可能导致反复释放或野指针问题。推广至Copy constructor、Move constructor、Copy assignment operator、Move assignment operator、Destructor这五个函数，定义了任何一个都会导致编译器认为你在主动管理资源，原本默认生成的函数可能无法满足需求甚至是错误的故被转换为delete强制用户手动实现，也就是`rule of five`规则。

##### 22

编译时出现如下错误

```C++
main_node.cpp:8: undefined reference to `WheelOdom<double>::WheelOdom()'
```

原因分析: 编译nodecpp时没有指定要链接定义WheelOdom的cpp文件; 模板类的成员函数的声明和定义分开了, 使模板类在实例化时不能使用类的模板，而是使用定义时的模板，这会产生构造和析构函数未定义的效果;

##### 23

错误提示如下:

```C++
空函数体的构造函数提示，赋值时两侧矩阵的行列不相同
```

原因分析：在声明函数时就对变量初始化, 初始化时赋值出现错误

##### 24

编译时出现如下错误

```C++
undefined reference to `LidarLocator::rtk2PointPose(rtk_msgs::Rtk_<std::allocator<void> >)'
```

原因分析: without "classname::" when define a member function

##### 25

编译时出现如下错误

```C++
‘rpy2Quat’ was not declared in this scope
```

原因分析: 编译有顺序, 被调用的代码必须在调用代码之前；

##### 26

编译时出现如下错误

```C++
(特殊)大量编译错误; many errors when compilation
```

原因分析: 链接文件时, 如果前一段.o文件有错误, 就会导致大量错误



##### 30

编译时出现错误的代码如下
```C++
QPainterPath path;
```
错误提示如下：
```C++
variable has incomplete type
```
因为没有包含该类型所在的头文件，包含`#include <QPainterPath>`后问题解决。


##### 32. 
安装yaml，已经基本确认`CMakeLists.txt`后，在编译时报错。
C++代码段如下
```C++
std::string config_file_path = WORK_SPACE_PATH + "/config/params.yaml";
YAML::Node config_node = YAML::LoadFile(config_file_path); // node用于存储解析后的 yaml 信息。
workMode = config_node["workMode"].as<std::string>();

```
编译时的错误如下
```C++
/tmp/ccCvErNZ.o: In function `YAML::detail::node& YAML::detail::node_data::get<std::string>(std::string const&, std::shared_ptr<YAML::detail::memory_holder>)':
cricket.cpp:(.text._ZN4YAML6detail9node_data3getISsEERNS0_4nodeERKT_St10shared_ptrINS0_13memory_holderEE[_ZN4YAML6detail9node_data3getISsEERNS0_4nodeERKT_St10shared_ptrINS0_13memory_holderEE]+0x94): undefined reference to `YAML::detail::node_data::convert_to_map(std::shared_ptr<YAML::detail::memory_holder>)'
collect2: error: ld returned 1 exit status
```
网上解决方案五花八门，其实可以通过安装合适的`yaml-cpp`来解决。我之前安装的是最新的`0.7.0`,重新安装`0.6.0`后，问题解决了。


##### 33. 可能包含错误
编译时出现如下错误
```C++
#error PCL requires C++14 or above
```
ubuntu20对应的ros为`noetic`，自带的`PCL1.10`，需要`C++14`.在`CMakeLists.txt`中添加`set(CMAKE_CXX_FLAGS "-std=c++14")`或`set(CMAKE_CXX_STANDARD 14)`都没用。应当添加如下代码
```C++
set(CMAKE_CXX_STANDARD 14)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
ADD_COMPILE_OPTIONS(-std=c++14 )
```

##### 34.
编译时出现如下错误
```C++
fatal error: opencv/cv.h: 没有那个文件或目录 错误
```
ubuntu20对应的ros为`noetic`，自带的是`opencv4`。将 `#include <opencv/cv.h>`替换为`#include <opencv2/opencv.hpp>`即可。

##### 35
编译时出现如下错误
```C++
fatal error: opencv/cxcore.h: 没有那个文件或目录 错误
```
ubuntu20对应的ros为`noetic`，自带的是`opencv4`。将 `#include <opencv/cxcore.h>`替换为`#include <opencv2/core/core_c.h>`即可。

##### 36 可能包含错误
编译时出现如下错误
```C++
error: ‘CvMat’ does not name a type
```
添加头文件
```C++
#include <opencv2/core/types_c.h>
```

##### 37 
编译时出现如下错误
```C++
error: ‘CV_RGB’ was not declared in this scope
```
添加头文件(适用于opencv3.2)
```C++
#include <opencv2/imgproc.hpp>
```

##### 38 
编译时出现如下错误
```C++
‘cvFindChessboardCorners’ was not declared in this scope
```
cmake里面写了这个库，vscode也能跳转到相关的头文件。但仍然报这个错误。<br />
原因分析: cmake默认包含的库和实际需要的库的版本不一致，实际需要的是`opencv3`。
解决方法：在cmake中添加版本参数，把`find_package(OpenCV REQUIRED)`改为`find_package(OpenCV 3 REQUIRED)`

##### 39 
编译时出现如下错误
```C++
definition of implicitly-declared
```
原因是，我在定义构造函数之前，没有声明构造函数。

##### 40
编译时出现如下错误
```C++
ISO C++ forbids taking the address of an unqualified or parenthesized non-static member function to form a pointer to member function
```
出现错误的代码类似以下代码
```C++
Class Base{
  public :
    Base(){boost::bind(&calibHandler, this, _1, _2);}
    void calibHandler() {}
};
```
`calibHandler`表示一个实例化对象的成员函数，`Base::calibHandler`只是一个普通的函数。成员函数只有在实例化的时候才存在，在编译过程中根本不存在该函数，而程序中使用了成员函数的地址，所以出现错误。一个普通函数在编译过程中就已经存在。因此，应改为如下形式，这种写法表示调用一个普通的函数。
```C++
boost::bind(&Base::calibHandler, this, _1, _2);
```

##### 41 vtk
Compiler throw a error that there's not vtk. Refer [this](https://zhuanlan.zhihu.com/p/183099001).

##### 42 
C＋＋，打不出＼键，其他软件能打出来。检查文件系统是不是日文，我日文没有\，所以将\会转换成一个和￥很像的符号。

##### 43
编译时出现如下错误
```Bash
error: ‘any’ is not a member of ‘std’
```
原因分析: std::any and std::any_cast were added in c++17<br />
解决方法： make sure that you are compiling with the correct version.

##### 44
编译时出现如下Warning
```Bash
CMake Warning (dev) at XXX/CMakeLists.txt:103 (add_dependencies):
Policy CMP0046 is not set: Error on non-existent dependency in add_dependencies.
```
解决方法：在 CMakeLists.txt 文件中加入下面一行：
```C++
cmake_policy(SET CMP0046 OLD)
```

##### 45
编译时出现如下错误
```Bash
undefined reference to `YAML::BadConversion'
undefined reference to `YAML::BadConversion::~BadConversion()'
undefined reference to `YAML::detail::node_data::convert_to_map'
```
解决方法: 卸载新版本的`yaml`，安装`0.5.1`版本<br>
You will meet this error if you don't add yaml library in `CMakeLists.txt`.


##### 46
编译时出现如下错误
```Bash
Warning: File '/include/utility.h' has modification time 26170 s in the future
 warning:  Clock skew detected.  Your build may be incomplete.
```
出现这一问题是由于文件时间比系统时间晚造成的.
解决方法：   使用touch指令`touch FILE_NAME`(如果是编译的机器时间不准可能没用)

##### 47
编译时出现如下错误
```Bash
fatal error: myutility.hpp: No such file or directory
```
header exist. add `include_directories(include ${catkin_INCLUDE_DIRS})` into `CMakeLists.txt`.

##### 48
```Bash
multiple definition of .. first defined here
```
header file contains definition of function and this file is inckuded several time, which causes multiple definition. Try to seperate declaration and definition or declare function as `static`.

##### 49
C++代码段如下
```C++
ros::Subscriber subLidar = nh.subscribe<sensor_msgs::PointCloud2>(lidarTopic, 1, ManualCalib::cloudHandler, this);
```
编译时出现如下错误
```Bash
invalid use of non-static member function ‘void ManualCalib::cloudHandler(const PointCloud2ConstPtr&)
```
解决方案如下
```C++
ros::Subscriber subLidar = nh.subscribe<sensor_msgs::PointCloud2>(lidarTopic, 1, &ManualCalib::cloudHandler, this);
```

##### 50
C++代码段如下
```C++
#include <opencv2/core/eigen.hpp>
cv::eigen2cv(camera_matrixE, camera_matrix);
```
编译时出现如下错误
```Bash
eigen.hpp:63:22: error: Eigen does not name a type Eigen::Matrix
```
解决方案如下
```C++
#include <Eigen/Dense>
#include <opencv2/core/eigen.hpp>
cv::eigen2cv(camera_matrixE, camera_matrix);
```

##### 51
编译时出现如下警告
```Bash
warning "will be initialized after [-Wreorder]
```
构造函数时，初始化成员变量的顺序要与类声明中的变量顺序相对应，若不对应，则出现如题错误。解决方法就是按照顺序进行初始化。

##### 52
编译时出现如下错误
```Bash
no matching function for call to ‘ros::NodeHandle::subscribe
```
有可能是回调函数的问题。回调函数得实参类型必须是ros封装的以`ConstPtr`结尾的数据类型。

##### 53
编译时出现如下错误
```Bash
undefined reference to `ros::spinOnce()'
```
如果编译的程序中存在ros的组件，必须在`CmakeLists.txt`中链接ros，示例如下
```
target_link_libraries(test_node ${catkin_LIBRARIES})
```


##### 54
在C++中使用qt并使用cmake构建，编译时遇到错误
```Bash
"undefined reference to `vtable for MainWindow'"
```

```Bash
find_package(Qt5 COMPONENTS Core Gui Widgets REQUIRED) 
set(SOURCES 
  main.cpp
  myclass.cpp
  myclass.h
)
qt5_wrap_cpp(MOC_FILES myclass.h) # Call qt5_wrap_cpp() on any Qt header files to run moc automatically
add_executable(myApp ${SOURCES} ${MOC_FILES})
target_link_libraries(myApp Qt5::Core Qt5::Gui Qt5::Widgets)
```
The key points are:
1. Use qt5_wrap_cpp() to run moc on Qt header files; 
2. This generates moc_<file>.cpp source files; 
3. Add these generated moc files to your sources; 
4. Link against Qt5 libraries; 
5. Set CMAKE_AUTOMOC and CMAKE_AUTOUIC if using newer CMake versions

##### 55
在编译时出现如下警告
```Bash
ISO C++17 does not allow ‘register’ storage class specifier
```
ISO C++17 中不再支持 'register' 存储类说明符，可以简单地删掉 'register' 来解决编译警告，删除它不会影响代码功能,只是删除了一个无效的编译器提示。也可以在CMakeLists.txt文件中添加编译选项来抑制'register'存储类说明符的警告。例如:
```Bash
add_compile_options(-std=c++17 -Wall -Wextra)
add_compile_options(-Wno-deprecated-register)  # 添加这行来抑制所有'register'警告
add_executable(main main.cpp)
```
或者
```Bash
add_executable(main main.cpp)
target_compile_options(main PRIVATE -Wno-deprecated-register) # 抑制编译这个可执行文件时出现的'register'警告
```

##### 56
在编译时出现如下警告
```Bash
warning: ‘xxx’ will be initialized after [-Wreorder]
```
如果初始化列表中的初始化顺序与变量声明顺序不一致，就会出现上述警告

##### 57
写了一个ros包，用qt制作界面，编译时遇到如下错误。已经检查过了，所用到的头文件和可执行文件都正确写进了`CmakeLists.txt`文件。
```Bash
undefined reference to `vtable for MainWindow'
```

```CMake
### other statements ###
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)
### other statements ###
qt5_wrap_cpp(MOC_FILES include/display/mainwindow.h)
add_executable(map_test_node src/map_test_node.cpp ${MOC_FILES} src/display/mainwindow.cpp)
### other statements ###
```

##### 58
```bash
fatal error: json/json.h: No such file or directory #include <json/json.h>
```
即使安装了`libjsoncpp-dev`，仍然出现这个编译错误。需要将代码改为如下
```C++
#include <jsoncpp/json/json.h>
```

##### 59
使用`catkin_make`编译时使用anaconda的python导致编译出错。更改`.bashrc`文件甚至卸载删除了anaconda，运行`catkin_make`仍然使用的是anaconda的python。以下是分析和解决方案。

CMake的运行方式是先生成makefile文件，这些文件中指定了接下来使用哪些库、编译后的文件的位置等相关的编译指令。正常的编译流程是
```bash
rm -rf build
mkdir -p build
cmake .. # 生成makefile文件，这是真正控制编译的文件
make # 编译
```
`catkin_make`是先在`build`文件夹中产生对应的makefile文件，然后根据`build`文件夹的编译指令把文件编译到`devel`文件夹。

使用`catkin_make`编译时使用anaconda的python导致编译出错后，之后的操作一直没有删除`build`文件夹。而`catkin_make`只有当`CMakelists.txt`文件发生变化后才会自动重新生成编译指令。这导致一直使用了错误的编译指令，因此一直报错。实际上，在`.bashrc`文件中删除anaconda环境并重启终端后，只要删除`build`文件夹并重新运行`catkin_make`即可。


##### 60
```C++
void sys_writen(const void *vptr)
{
  const char *ptr;

  ptr = vptr;
}
```
以上代码在编译时遇到以下错误
```bash
error: invalid conversion from ‘const void*’ to ‘const char*’ [-fpermissive]
```
出现error的原因是C++设计得比C更加安全，它不能自动地将void *转换为其它指针类型。而出现warning的原因则是程序试图将字符串字面值（在C++中字符串字面值为const char []类型，而在C语言中则为char []类型）转换为char *类型，因此如果想要使用g++成功编译这个程序并得到预期的结果，可以将程序修改为
```C++
void sys_writen(const void *vptr)
{
  const char *ptr;

  ptr = (char *)vptr;
}
```

##### 61 
如果你的cmake版本高的话，`-std=c++17`是不起作用的，需要换成`set(CMAKE_CXX_STANDARD 17)``.

##### 62
编译时出现如下错误
```bash
在注释中遇到意外的文件结束
```
区间注释在文件末尾处没有结束。

---

## 二、运行错误

##### 01

运行崩溃的程序如下

```C++
Eigen::VectorXd odom_edge_noise; odom_edge_noise(0) = 0.1;
```

错误提示如下

```C++
/home/nnnn/Documents/my/li/src/frame/third_party/eigen3/Eigen/src/Core/DenseCoeffsBase.h:413: Eigen::DenseCoeffsBase<Derived, 1>::Scalar& Eigen::DenseCoeffsBase<Derived, 1>::operator()(Eigen::Index) [with Derived = Eigen::Matrix<double, -1, 1>; Eigen::DenseCoeffsBase<Derived, 1>::Scalar = double; Eigen::Index = long int]: Assertion `index >= 0 && index < size()' failed.
```

原因分析：在类的public中定义了一个动态向量，但未定义大小，然后在赋值时出现错误

解决方案如下

```C++
// (在类的构造函数中定义该动态向量的大小)
Eigen::VectorXd odom_edge_noise; odom_edge_noise.resize(6); odom_edge_noise(0) = 0.1;
```

##### 03

运行崩溃的程序如下

```C++
kdtreeLocalMapCorner->nearestKSearch(pointInMap, 5, searchedPointInd, searchedPointDis);
```

错误提示如下

```C++
lio_sam_fusedOptimization: /build/pcl-0nnAvv/pcl-1.7.2/kdtree/include/pcl/kdtree/impl/kdtree_flann.hpp:136: int pcl::KdTreeFLANN<PointT, Dist>::nearestKSearch(const PointT&, int, std::vector<int>&, std::vector<float>&) const [with PointT = pcl::PointXYZ; Dist = flann::L2_Simple<float>]: Assertion `point_representation_->isValid (point) && "Invalid (NaN, Inf) point coordinates given to nearestKSearch!"' failed.
```

原因分析：any of the x,y,z fields of a point are infinite; pointInMap 是个nan点;当存在无效点云的NaNs值作为算法的输入

##### 05

```C++
downSizeFilterSurf.setInputCloud(inLaserCloudSurf); // many points in this cloud
downSizeFilterSurf.filter(outLaserCloudSurfLast);   // only 1 or 2 points left
```

原因分析如下: points are nan

##### 07
代码段如下
```C++
class Base
{
 public:
  Base()
  {
    std::string config_file_path = WORK_SPACE_PATH + "/config/params.yaml";
    YAML::Node config_node = YAML::LoadFile(config_file_path);
    std::cout << "Base done" << std::endl;
  }
};
class Drived : public Base
{
 public:
  Drived(){std::cout << "Drived done" << std::endl;}
};
```

编译的时候正常，运行时出错。成功输出了`Base done`，然后就报错了。通过一些方法，确认错误发生在初始化`Drived`的成员之前，即没有进入初始化列表就出错了。错误提示如下
```C++
[node-5] process has died [pid 29437, exit code -11, cmd 
```

**方案一**
改为如下：
```C++
class Base
{
 public:
  Base()
  {
    std::cout << "Base done" << std::endl;
  }
};
class Drived : public Base
{
 public:
  Drived()
  {
    std::string config_file_path = WORK_SPACE_PATH + "/config/params.yaml";
    YAML::Node config_node = YAML::LoadFile(config_file_path);
    std::cout << "Drived done" << std::endl;
  }
};
```
这种方法可以规避上述运行时的错误。但在进一步使用`yaml-cpp`读取参数时，出现问题“YAML::detail::node_data::convert_to_map”(可以在本文搜索引号中的内容)。<br>
**方案二**
之前安装的是最新的`yaml-cpp 0.7.0`,重新安装为`yaml-cpp 0.6.0`后，问题解决了。


##### 9
运行时出现以下错误，而且其中所需要的库已经安装了
```
error while loading shared libraries: libnlopt.so.0: cannot open shared object file: No such file or director
```
原因分析：This might happen if you have recently installed a shared library and didn't run ldconfig(8) afterwards. Do 'ldconfig', there's no harm in it.
运行命令`sudo ldconfig`即可解决。

##### 10
c语言程序debug有值，run运行打印值却是初始值?变量前加个volitate试一下

##### 11
std::uint16_t a = 9; 
std::uint8_t b = a; 
a has value, but b is null;

##### 12 exit code -11

具体的错误提示如下

```C++
[loop_closing_node-5] process has died [pid 29437, exit code -11, cmd /home/nnnn/Documents/my/li/devel/lib/frame/loop_closing_node __name:=loop_closing_node __log:=/home/nnnn/.ros/log/af90aa56-dcc2-11eb-9108-024258b94a05/loop_closing_node-5.log].
```

原因分析：新建向量变量，没有指定大小，直接用下标引用; 指针没有分配空间; 访问opencv的矩阵时越界; 访问数组时,下标越界,上越界或下越界;`std::size_t`类型计算过程中出现负值;

解决方案：使用向量前指定向量大小；使用更大的矩阵或者不要越界访问。

##### 13 exit code -6

原因分析：内存访问错误，可能的原因有访问不存在的变量; assignment of yaml node can destroy original node;`std::thread`类型的线程，如果线程已经初始化，且没有调用`detach()`，那么该线程处于`joinable`状态，则必须线调用`join()`函数结束线程之后再调用析构函数，否则会导致在析构时出现该错误;

##### 14 exit code -11
运行崩溃的程序如下
```C++
std::mutex mtxParam;
{
  std::lock_guard<std::mutex> lock(mtxParam);
  readParams( );
  lock.~lock_guard( );
}
```
原因分析：I guess `lock` is deconstructed twice.<br>

解决方案如下
```C++
std::mutex mtxParam;
{
  std::lock_guard<std::mutex> lock(mtxParam);
  readParams( );
}
```

##### 15 exit code -6 ; yaml
运行崩溃的程序如下
```C++
std::string config_file = WORK_SPACE_PATH + "/config/params.yaml";
YAML::Node config_node = YAML::LoadFile(config_file);

YAML::Node cur_node;

cur_node = config_node["camera_calib"]["board"]; // It's likely that config_node is reset as "config_node["camera_calib"]["board"]"

cur_node = config_node["camera_calib"]["file_path"]; // This node is null because this node have been changed.
```
解决方案如下
```
std::string config_file = WORK_SPACE_PATH + "/config/params.yaml";
YAML::Node config_node = YAML::LoadFile(config_file);

std::string cur_field;
YAML::Node cur_node;

cur_node.reset(config_node["camera_calib"]["board"]);

cur_node.reset(config_node["camera_calib"]["file_path"]);
```

I'm not sure, because code below can run correctly.
```C++
std::string config_file = WORK_SPACE_PATH + "/config/params.yaml";
YAML::Node config_node = YAML::LoadFile(config_file);

YAML::Node cur_node1 = config_node["camera_calib"]["board"];

YAML::Node cur_node2 = config_node["camera_calib"]["file_path"];
```

无论 `=` 还是 `reset`，都是对原变量的引用，不是复制赋值。

##### 16 exit code -15

##### 17 
编译时选择最高级优化“-03”，可能会导致向文件流输入时出现如下错误。
```Bash
Segmentation fault (core dumped)
```
 
##### 18
```C++
std::vector<Eigen::Vector4d> parametersVector;
parametersVector.emplace_back(parametersPlane);
```
改为已下形式：
```C++
vector<Eigen::Vector4d ,Eigen::aligned_allocator<Eigen::Vector4d>> paramaterPlaneVector;
```

##### 19
```C++
std::vector<double> vec = {1.0, 2.0, 3.0};
cv::Mat mat = cv::Mat(vec);
```
对于以上程序，如果vec的存在期短于mat,即vec被销毁,访问mat的数据是不安全的,会访问已经释放的内存。应改为如下代码
```C++
std::vector<double> vec = {1.0, 2.0, 3.0};
cv::Mat mat = cv::Mat(vec).clone();
```
##### 20
程序莫名其妙跳出了for循环并从for循环之前的代码继续执行；是否添加`cout`会导致不同的报错；出现`double free`或者`segment fault`等诸多错误。经过分析，是因为函数缺少返回值。代码如下。原代码没有返回语句(即注释掉的代码)。添加返回语句后，程序正常执行。
```C++
bool func()
{
  // return true;
}
```

##### 21
编译过程正常，运行时报错。而且报错的程序段没有执行。报错信息如下：
```Bash
Assertion `(internal::UIntPtr(eigen_unaligned_array_assert_workaround_gcc47(array)) & (15)) == 0
```

##### 22
以下函数因为没有返回值，在调用时可能会出现该函数`adds`被反复执行的情况。
```C++
extern "C" bool adds(int *idata_host, int *odata_host, int size, int blocksize)
{
  /** code **/
  // return true;
}
```