---
layout: post
title:  "C++编译流程"
date:   2022-11-20 08:30:00 +0800
categories: [Lan]
excerpt: C++编译
tags:
  - 编译
  - C++
---

### 1. 整体流程
1. 预处理
* `#include`是一个来自`C`语言的宏命令，在编译器进行编译之前把它后面所写的那个文件的内容，完完整整地、一字不改地包含到当前的文件中来，没有其它任何作用与副功能的。系统自带的头文件用尖括号括起来，这样编译器会在系统文件目录下查找。自定义的文件用双引号括起来，编译器首先会在用户目录下查找，然后再到 C++ 安装目录找。
* 把同一个头文件多次用`include`包含进`cpp`文件里，可能会出现不良后果。如果在头文件开头使用`#ifndef...#endif`，那么在第一次include后，就已经有了相应的宏定义，第二次再试图include时，就不再满足`#ifndef`的条件，也就不会再次执行include。`#pragma once`也可以起到类似作用。
<br>
显然，在预处理的过程中，被include的文件的内容已经被复制到了对应的地方，因此编译过程中不会再处理被include的文件。

2. 编译
这个过程就是把源文件转换成二进制的机器码，即生成`.o` 或 `.obj` 目标文件。
* 目标文件中没有定义的函数和变量就视作一个个符号，并把这些符号放进符号表（symbol table）中，然后在链接过程中再去找具体的定义。
* 编译器在这个过程中针对源代码执行优化。


3. 链接
在链接的时候，需要在`makefile`里面说明需要连接哪个 `.o` 或 `.obj` 文件，此时，连接器会去这个 `.o` 或 `.obj` 文件中找在 b.cpp 中实现的函数，再把他们 `build` 到 `makefile` 中指定的那个可以执行文件中。通常，C++ 编译器会在每个 .o 或 .obj 文件中都去找一下所需要的符号，而不是只在某个文件中找或者说找到一个就不找了。因此，如果在几个不同文件中实现了同一个函数，或者定义了同一个全局变量，链接的时候就会提示 "redefined"或者`multiple definition of ..`。

### 2. 注意事项
1. 一个符号，在整个程序中可以被声明多次，但能且仅能被定义一次。

2. 根据上述编译流程，如果被include的文件中有函数或变量的定义，那么当它被多个文件包含时，这些函数和变量就被定义了多次。在链接过程中就会出现类似“多次定义”的错误。但有三个例外
* const 对象的定义。因为全局的 const 对象默认是没有 extern 的声明的，所以它只在当前文件中有效，在链接时也不会为此类对象查找定义。
* 类（class）的定义。
* 头文件中可以写内联函数（inline）的定义。因为内联函数在预处理过程中就会被直接复制到函数被调用的地方，就像include的复制一样，也不会在符号表中添加符号。在编译和链接过程中，也就不会出现“找到一个符号的多个定义”的错误。




# cmake 

1. 设置编译选项可以通过add_compile_options命令，也可以通过set命令修改CMAKE_CXX_FLAGS或CMAKE_C_FLAGS。但是set命令设置CMAKE_C_FLAGS或CMAKE_CXX_FLAGS变量则是分别只针对c和c++编译器的.

2. 
```shell
# 查找当前目录下的所有源文件，并将名称保存到 DIR_SRCS 变量
aux_source_directory(. DIR_SRCS)
```

3. add_library的主要作用就是将指定的源文件生成链接文件，然后添加到工程中去
```shell

```

4. link_directories 的作用主要是指定要链接的库文件的路径，该指令有时候不一定需要。因为find_package和find_library指令可以得到库文件的绝对路径。不过你自己写的动态库文件放在自己新建的目录下时，可以用该指令指定该目录的路径以便工程能够找到。