---
layout: post
title:  "docker"
date:   2025-04-22 23:59:18 +0800
categories: [Tech]
excerpt: How to use docker and common solution
tags:
  - docker
---

I will use `7dd6d89ffda8` as container ID, `a294gh092j34` as image ID and `festive_edison:latest` as image name in my examples.

### image

1. list all local images

```bash
# with trunc SHA256 hash
docker images
# with entire SHA256 hash
docker images --no-trunc
```

2. delete image

```bash
docker rmi a294gh092j34
```

3. save image to file

```bash
# works with images and retains history and metadata.
docker save -o <output_file>.tar <image_name>
```

4. load file to image

```bash
# If you have a tarball created using docker save, use docker load instead. Both commands do the same thing, but the version with < uses shell redirection to handle it, whereas -i specifies the input file directly.
docker load < image.tar
docker load -i <path_to_tar_file>.tar
```

### container

1. start from an image

```bash
# create a container for image "ubuntu", start this container and step in it on command-line mode
# -v: map path in host to path in container 
# --name: set container's name as 
# -i: interactive
# -t: command-line
# ubuntu:1.0, name and tag of image
# /bin/bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。
docker run -v ./data:/media/data --name container5 -it ubuntu:1.0 /bin/bash
```

2. list all local containers

```bash
docker ps -a
```

3. get in a running container

```bash
docker attach 7dd6d89ffda8
```

4. import and export containers

```bash
# export container to file. works with containers and includes the filesystem without image history or metadata, like container name, port mappings, volumes, environment variables, and layers from the original image, CMD, ENTRYPOINT. the files stored in the container become part of the new image created during the import process.
docker export 7dd6d89ffda8 > ubuntu.tar

# import file as image "test/ubuntu:v1". a new image is created from the filesystem archive of the exported container. 
cat docker/ubuntu.tar | docker import - test/ubuntu:v1
docker import container.tar test/ubuntu:v1
```

5. find out which image a Docker container originated from

```bash
docker inspect 7dd6d89ffda8 | grep Image
# or
docker inspect 7dd6d89ffda8 --format='{{.Config.Image}}'
```

6. start a container

```bash
docker start 7dd6d89ffda8
```

7. CMD
The `CMD` is defined at the time of container creation. To change it, you must create a new container based on the existing one, overriding the `CMD`.

8. export container to image

```bash
docker commit 7dd6d89ffda8 festive_edison
```

`7dd6d89ffda8` is container's name. Name of new image is `festive_edison`.

9. delete a container

```bash
```

10. copy file or folder to host

```bash
docker cp my_container:/path/to/file /local/path
```

### Docker Image Cross-Platform Usage

A Docker image or container exported on Ubuntu can generally be used on Windows, vice versa.

### display on Windows

##### install and launch XcXsrv on Windows

1. download from [here](https://sourceforge.net/projects/vcxsrv)
2. allow XcXsrv access all net
3. Select display setting: "Multiple windows" is default and recommended. Leave "Display number" as -1.
4. Select how to start clients: Leave it as default.
5. Extra settings: select "Disable access control".

##### configuration in docker container

1. install some package

```bash
sudo apt install xfce4-terminal
sudo apt install xfce4
sudo apt install x11-apps
```

2. edit .bashrc: add code below to file .bashrc and source it to enable it.

```bash
export DISPLAY=$(grep -m 1 nameserver /etc/resolv.conf | awk '{print $2}'):0
export WAYLAND_DISPLAY=$DISPLAY
export XDG_SESSION_TYPE=X11
```

Docker container can display now.

It's possible that you should configure `nameserver` in file `/etc/resolv.conf`. Open `PowerShell` and run `ipconfig` to check IP address. Replace IP address in `/etc/resolv.conf` with this address.

# other

##### 1. configuration file of docker

Configuration file of docker is `/etc/docker/daemon.json`. You can add code below to reset registry. It will be activated when docker is restarted.

```json
{
    "registry-mirrors": [
        "http://hub-mirror.c.163.com",
        "https://docker.mirrors.ustc.edu.cn",
        "https://registry.docker-cn.com"
    ]
}
```

##### 2. why need sudo

It's normal to require sudo when running Docker commands on Ubuntu by default. This happens because the Docker daemon (the service that manages Docker containers) runs with root privileges, and users who are not in the docker group must use sudo to access it.

##### 3. sudo and privileged

Using `sudo` affects only the host-side permissions to execute Docker commands, while `--privileged` changes the security model and capabilities within the container itself. They are separate and have different implications for container security and isolation.

##### 4. bind volume

You won’t be able to modify the bind mount directly because Docker doesn’t support changing mount options (like read-only) on an existing container, which means you have create a new container with a bind mount like command below:

```bash
# -v path on host : path on container
docker run -it -v /home/user/project:/usr/src/app festive_edison /bin/bash
```

##### 5. write speed

Speed of Writing on volume in container is much, much faster than that in binded volume. And speed of the latter isn't stable.

# Q&A

##### 1. docker and internet

```bash
net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)
# 或
net/http: TLS handshake timeout
# 或
request canceled (Client.Timeout exceeded while awaiting headers)
```

or 

```bash
Error response from daemon: Get "https://registry-1.docker.io/v2/": net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)
```

or

```bash
Error response from daemon: Get "https://registry-1.docker.io/v2/": dial tcp ip: connect: connection refused
```

[reference](https://blog.csdn.net/2301_79849395/article/details/142829852)

solution using VPN:

1. prepare a valid VPN
2. run `sudo mkdir -p /etc/systemd/system/docker.service.d` to create a folder
3. run `sudo touch /etc/systemd/system/docker.service.d/http-proxy.conf` to create a configuration file.
4. run `sudo vim /etc/systemd/system/docker.service.d/http-proxy.conf` to open it.
5. add configuration like below into it. Note that use your own proxy link.

```conf
[Service]
Environment="HTTP_PROXY=http://localhost:8889/"
Environment="HTTPS_PROXY=http://localhost:8889/"
```

6. restart docker using commands below

```bash
sudo systemctl daemon-reload
sudo systemctl restart docker
```

##### 2. several commands in dockerfile

problem: Got error when I used `Dockerfile` to create a docker image.
solution: perform every command in Dockerfile step by step manually.

##### 3. without default command

An error when run a image:

```bash
Failed to run image. (HTTP code 400) bad parameter - no command specified
```

reason: I created this image from a container and didn't add default cmd into this image.

solution: create a new `Dockerfile` based on the existing image.
If this image is linux-based:

```Dockerfile
FROM myimage:latest
CMD ["/bin/bash"]
```

If this image is Windows-based:

```Dockerfile
FROM myimage:latest
CMD ["cmd.exe"]
```

##### 4. interactive mode and command-line mode

container exit with code 0 at once when I start a container. </br>
reason: the container doesn't start with interactive mode and step in it on command-line mode.</br>
solution: I run `docker rum -it festive_edison:latest`. Note that command `/bin/sh` will be run automatically after a container start in this instance.

##### 5. KVM

I got `KVM is not enabled on host` when I started docker desktop.
`Docker Desktop` on Linux relies on a virtual machine as its backend. If `KVM` is not available, the default VM backend won't work. Use command `egrep -c '(vmx|svm)' /proc/cpuinfo` to check whether a CPU supports virtualization. If the output is 0, this CPU does not support virtualization, or it is disabled in the BIOS/UEFI.
