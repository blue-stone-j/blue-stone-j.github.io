---
layout: post
title:  "PCLå­¦ä¹ "
date:   2025-06-24 22:21:26 +0800
categories: [Tech]
excerpt: å¸¸ç”¨PCLå‡½æ•°ï¼›PCLçš„æ•°æ®ç»“æ„ï¼›ç­‰ç­‰ã€‚
tags:
  - PCL
  - C++
---

è¿™ç¯‡æ–‡ç« æ•´ç†äº†å¸¸ç”¨PCLå‡½æ•°(ç”¨é€”ã€å‚æ•°çš„æ„ä¹‰ï¼Œå¿…è¦æ—¶ä¹Ÿä¼šåˆ—å‡ºè¯¥å‡½æ•°æ‰€åœ¨çš„å¤´æ–‡ä»¶)ä»¥åŠä¸€äº›å…¶å®ƒå…³äºPCLåº“çš„çŸ¥è¯†ã€‚

# install

ubuntu20 çš„é»˜è®¤å®‰è£…æ˜¯ä¸åŒ…å«gpuå’Œcudaæ¨¡å—çš„ã€‚å¦‚æœè¦ä½¿ç”¨è¿™ä¸¤ä¸ªæ¨¡å—ï¼Œå¿…é¡»é€šè¿‡æºç ç¼–è¯‘å®‰è£…ï¼Œåœ¨ç¼–è¯‘æ—¶ä¹Ÿè¦é€‰æ‹©å¯¹åº”çš„æ¨¡å—ã€‚

### 1. ä¸‹è½½1.10.1

æ³¨æ„ä¸è¦ä½¿ç”¨1.10.0è¿™ä¸ªç‰ˆæœ¬ï¼Œè¿™ä¸ªç‰ˆæœ¬çš„æºç å­˜åœ¨bugï¼Œæ— æ³•æ­£ç¡®å®Œæˆç¼–è¯‘å®‰è£…ã€‚

### 2. æ‰§è¡Œcmake

æ‰§è¡Œ`cmake .. -DCMAKE_BUILD_TYPE=Release`é…ç½®cmakeã€‚

1. å¦‚æœæŠ¥å’Œ `ccmake` ç›¸å…³çš„é”™è¯¯ï¼ŒæŒ‰ç…§ç»ˆç«¯æç¤ºè¾“å…¥ `sudo apt-get install cmake-curses-gui` å®‰è£…åå†è¿è¡Œ
2. `By not providing "Findrealsense2.cmake" in CMAKE_MODULE_PATH this project has asked CMake to find a package configuration file provided by "realsense2", but CMake did not find one.`: `sudo apt install ros-$ROS_DISTRO-realsense2*`
3. `Unsupported gpu architecture 'compute_30'`: gpuçš„ç¡¬ä»¶æ¶æ„ä¸æ”¯æŒ'compute_30'ï¼ŒæŠŠé…ç½®cmakeçš„ç•Œé¢ä¸­çš„`CUDA_ARCH_BIN`å¯¹åº”çš„å³ä¾§é‡Œçš„"3.0"åˆ é™¤ï¼Œè¿™æ ·å°±ä¸éœ€è¦é’ˆå¯¹â€œ3.0â€è¿™ä¸ªæ¶æ„ç”Ÿæˆåº“æ–‡ä»¶ã€‚
4. `/home/hyc-pc/software/pcl/cuda/common/include/pcl/cuda/point_cloud.h(199): error: shared_ptr is not a template`: è¿™æ˜¯1.10.0ç‰ˆæœ¬å­˜åœ¨çš„bugï¼Œä¸‹è½½1.10.1å†å®‰è£…ã€‚

# Empirical Observation

sort by alphabet.

### pcl::Octree

##### adoptBoundingBoxToPoint

This function can adjust bounding box even the box has been defined manually.

##### defineBoundingBox

`pcl::Octree::OctreePointCloud::defineBoundingBox`: input bounding box will be used as initial bounding box first. Then the box will be adjusted to a cube. The adjusted bounding box always is different with the initial bounding box.

##### getIntersectedVoxelKeys

* PCL uses a 3D variant of the Bresenhamâ€™s line algorithm or Amanatides and Wooâ€™s voxel traversal algorithm. These algorithms traverse the octree in an efficient, grid-aligned manner.
* The worst-case time complexity can be estimated as ğ‘‚(ğ‘›). Average case is ğ‘‚(ğ‘˜+logğ‘›), where ğ‘˜ is the number of intersected voxels. Best case is ğ‘‚
(logğ‘›)(traversing a few nodes if the ray is short or only passes through a few voxels).
* The returned value of `pcl::Octree::getIntersectedVoxels` is not guaranteed to be sorted by default.

##### getIntersectedVoxelCenters

```C++
pcl::octree::OctreePointCloudSearch::getIntersectedVoxelCenters(Eigen::Vector3f origin,
                                                                Eigen::Vector3f direction,
                                                                AlignedPointTVector& voxel_center_list,
                                                                int max_voxel_count);
```

whether normalize `direction` can influence the result.

1. Best Case: $ğ‘‚(logâ¡(ğ‘))$ In the ideal case, the octree is well-balanced, and the ray intersects only a small number of voxels, minimizing traversal.
2. Average Case: $ğ‘‚(ğ‘˜+log(ğ‘))$ Where ğ‘˜ is the number of voxels intersected by the ray. Traversing the octree to find the ray's starting position is $ğ‘‚(logâ¡(ğ‘))$, and processing intersected voxels depends on ğ‘˜.
3. Worst Case: $ğ‘‚(ğ‘˜)$ If the ray intersects a large number of voxels (e.g., when the ray passes through the entire octree), the complexity is proportional to the number of intersected voxels.

##### radiusSearch

The distances are not necessarily sorted. If known in advance that radius 0.5 m always yields ~10 points, then radius search may be faster.

Set the resolution to be between `r/2` and `r`, where `r` is your search radius.

| Resolution      | Description                   | Use When                                |
| --------------- | ----------------------------- | --------------------------------------- |
| search_radius   | Coarser tree, faster to build | For very large datasets or many queries |
| search_radius/2 | Balanced, good performance    | Recommended default                     |

##### nearestKSearch

The KNN results are sorted by increasing distance.

##### getBoundingBox

```C++
getBoundingBox(min_x, min_y, min_z, max_x, max_y, max_z);
```

##### key

The key of a voxel is represented by a triple of integer values (ğ‘˜ğ‘’ğ‘¦_ğ‘¥,ğ‘˜ğ‘’ğ‘¦_ğ‘¦,ğ‘˜ğ‘’ğ‘¦_ğ‘§), which are discretized coordinates at a given octree depth.

1. Moving along the X-axis
Positive direction (+X): key_x increases by 1.
Negative direction (-X): key_x decreases by 1.
2. Moving along the Y-axis
Positive direction (+Y): key_y increases by 1.
Negative direction (-Y): key_y decreases by 1.
3. Moving along the Z-axis
Positive direction (+Z): key_z increases by 1.
Negative direction (-Z): key_z decreases by 1.

##### leaf traversal

leaf_begin(): breadth-first
leaf_depth_begin(): depth-first manner

### pcl::PointCloud

Time complexity of `makeShared` is `O(n)`.

### pcl::ConcaveHull

```C++
#include <pcl/surface/concave_hull.h>
int main (int argc, char** argv)
{
  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>), cloud_hull(new pcl::PointCloud<pcl::PointXYZ>);
  // load file to cloud
  pcl::ConcaveHull<pcl::PointXYZ> concave_hull;
  concave_hull.setInputCloud (cloud);
  concave_hull.setAlpha (0.1); // è®¾ç½®alphaå€¼ï¼Œæ ¹æ®éœ€è¦è°ƒæ•´ã€‚å†³å®šå‡¹åŒ…è®¡ç®—çš„ç´§å¯†ç¨‹åº¦ï¼šè¾ƒå°çš„å€¼ä¼šç”Ÿæˆæ›´ç´§å¯†ã€æ›´è¯¦ç»†çš„è½®å»“ï¼Œä½†å¯èƒ½ä¼šå¯¼è‡´æ›´å¤šçš„å°æ´å’Œç¢ç‰‡ï¼›è¾ƒå¤§çš„å€¼ä¼šç”Ÿæˆæ›´å¹³æ»‘çš„è½®å»“ã€‚
  concave_hull.reconstruct (*cloud_hull);
}
```

### pcl::MovingLeastSquares

Areas with more original points get more upsample.

# ä¸€ã€åŸºç¡€çŸ¥è¯†

#### 1. data()

#### 2

# ä¸‰ã€ä½å§¿å˜æ¢

```C++
#include <pcl/common/transforms.h> //ä¸»è¦å†…å®¹ä¸ºï¼šè¡¨ç¤ºä½å§¿çš„å‡ ç§æ–¹æ³•ä¹‹é—´çš„è½¬æ¢
//cloud_inå’Œcloud_outä¸º::Ptrç‚¹äº‘æŒ‡é’ˆ; Matrix4f=Affine3f
void pcl::transformPointCloud(const *cloud_in, *cloud_out, const Eigen::Matrix4f  & transform)
```

##### 2. pcl/common/eigen.h

> 4Ã—4å˜æ¢çŸ©é˜µ transformation Eigen::Affine3f ä»¿å°„çŸ©é˜µ --> poså’Œrpy ä½ç½®å’Œè§’åº¦ 6Dä½å§¿ ï¼›è¾“å…¥å’Œè¾“å‡ºå‚æ•°ä¸ºfloat

```C++
#include <pcl/common/eigen.h>

// ç²¾åº¦å¯èƒ½å­˜åœ¨é—®é¢˜
pcl::getTranslationAndEulerAngles(imuOdomAffineLast, x, y, z, roll, pitch, yaw);

// è¾“å…¥å’Œè¾“å‡ºå‚æ•°ä¸ºfloat
Eigen::Affine3f lastPoseInMapAff = pcl::getTransformation(x, y, z, roll, pitch, yaw);
```

# å››ã€åŒ¹é…å’Œé…å‡†

### 1. ndt.h

```C++
setTransformationEpsilon(ndt_epsilon_); // the transformation epsilon in order for an optimization to be considered as having converged to the final solution.
setStepSize(ndt_step_size_); // Set the newton line search maximum step length.
setResolution(ndt_resolution_); // Set the voxel grid resolution.
getFitnessScore(double max_range = std::numeric_limits<double>::max()); // Obtain the Euclidean fitness score (e.g., mean of squared distances from the source to the target)
```

### 2. pcl/kdtree/kdtree_flann.h

```C++
#include <pcl/kdtree/kdtree_flann.h>
// max_nn: num of returned points, if max_nn==0, return all.
kdtreeSurroundingKeyPoses->radiusSearch(point, radius, k_indices, k_sqr_distances, max_nn);
pcl::moveFromROSMsg(currentCloudMsg, *laserCloudIn);
```

### 3. pcl/registration/icp.h

```C++
#include <pcl/registration/icp.h>
pcl::IterativeClosestPoint<pcl::PointXYZ, pcl::PointXYZ> icp;
pcl::PointCloud<pcl::PointXYZ>::Ptr loopSourceCorner;
icp.setInputSource(loopSourceCorner); //æ³¨æ„è¾“å…¥çš„ç‚¹äº‘çš„æ•°æ®ç±»å‹ä¸ºPtr
```

## äº”ã€æ–‡ä»¶å¤„ç†

##### 1. åŠ è½½æ–‡ä»¶

```C++
#include <pcl/io/pcd_io.h>
//temFilePathåŒ…å«æ–‡ä»¶åå’Œåç¼€;thisCornerCloudä¸º::Ptrç‚¹äº‘æŒ‡é’ˆ;
pcl::io::loadPCDFile(temFilePath, *thisCornerCloud);
```

## other

##### 1. fields of point type

You can use the following code to print out the fields of your registered point type and verify the order:

```C++
template <typename PointT>
void printPointTypeFields() {
    std::cout << "Fields in the point type:\n";
    for (const auto& field : pcl::traits::fieldList<PointT>::type::fields) {
        std::cout << "  " << field.name << "\n";
    }
}
```

## æœ«ã€Q&A

##### 1. pcl_viewer segment fault

è¿è¡Œ`pcl_viewer`æ—¶æç¤ºé”™è¯¯`segment fault(core dump)`ã€‚å¯èƒ½æ˜¯å› ä¸ºé©±åŠ¨å®‰è£…æœ‰é—®é¢˜ï¼Œæˆ–è€…pclçš„ç‰ˆæœ¬ä¸é€‚é…ã€‚

##### 2. register a point type

Code below is used to define and register a point type to PCL.

```C++
#include <pcl/point_types.h>

namespace custom_pcl
{
  struct MyCustomPoint
  {
    PCL_ADD_POINT4D;  // This macro adds padding for alignment and the XYZ fields
    int id;           // Add the custom field `id`
    EIGEN_MAKE_ALIGNED_OPERATOR_NEW  // Ensure proper alignment
  };
}

POINT_CLOUD_REGISTER_POINT_STRUCT(
  custom_pcl::MyCustomPoint,  // Fully qualified name of the struct
  (float, x, x)               // Mapping: type, field name in struct, field name in PCL
  (float, y, y)
  (float, z, z)
  (int, id, id)               // Include the new `id` field
)
```

Note that the `POINT_CLOUD_REGISTER_POINT_STRUCT` macro must be placed in the global namespace. You cannot place it inside a namespace because the macro relies on global templates and compile-time mechanisms that PCL expects in the global scope. However, you can still define your custom point type within a namespace. Only the macro itself has to remain in the global scope.

##### 3. Define a point type from existing point type in PCL

```C++
namespace custom_pcl
{
  struct EIGEN_ALIGN16 MyCustomPoint : public pcl::PointXYZINormal
  {
    int id;  // Additional field
    EIGEN_MAKE_ALIGNED_OPERATOR_NEW  // Ensure proper memory alignment
  };
}

POINT_CLOUD_REGISTER_POINT_STRUCT(
  custom_pcl::MyCustomPoint,
  (float, x, x)
  (float, y, y)
  (float, z, z)
  (float, intensity, intensity)
  (float, normal_x, normal_x)
  (float, normal_y, normal_y)
  (float, normal_z, normal_z)
  (float, curvature, curvature)
  (int, id, id)
)
```

Then I got a warning.

```bash
warning: offsetof within non-standard-layout type 'MyCustomPoint' is conditionally-supported [-Winvalid-offsetof]
```

Standard Layout Requirements:

1. A standard-layout type is one where all non-static data members are laid out in a well-defined order in memory, and there is no ambiguity due to inheritance.
2. Adding new fields to a derived class makes the layout non-standard because the base class may already contain its own fields, making offsets potentially ambiguous.

##### 4

code below

```C++
template <class PointT>
bool calculateNormal(const pcl::PointCloud<PointT>::Ptr &cloud, Eigen::Vector3f &normal) {}
```

I got an error during compilation:

```bash
error : need 'typename' before 'pcl::PointCloud<PointT>::Ptr' because 'pcl::PointCloud<PointT>' is a dependent bool calculateNormal(const pcl::PointCloud<PointT>::Ptr &cloud, Eigen::Vector3f &normal)
```

The error arises because in a templated function, PointT is a dependent type, and the compiler needs explicit help to identify `pcl::PointCloud<PointT>::Ptr` as a type. To fix this, you must use the typename keyword to specify that it is a type. Here's the corrected code:

```C++
template <typename PointT>
bool calculateNormal(const typename pcl::PointCloud<PointT>::Ptr &cloud, Eigen::Vector3f &normal) {}
```

In fact, the corrected code can't be compiled successfully. Because

##### 5

```bash
octree_search.hpp : 396 : 46 : error : 'const struct custom::PointType' has no member named 'getVector3fMap' return (point_a.getVector3fMap() - point_b.getVector3fMap()).squaredNorm();
```

The error indicates that the structure custom::PointType does not have a member function or attribute named getVector3fMap. This function is a part of the PCL library for points that are derived from pcl::PointXYZ or similar types. Your custom PointType struct likely does not inherit from a pcl::PointXYZ-like structure or does not implement this function.

##### 6

The macro `EIGEN_MAKE_ALIGNED_OPERATOR_NEW` and `EIGEN_ALIGN16` is not strictly necessary for C++17 in most cases, because C++17 introduced guarantees for aligned memory allocation through new alignment-aware operators like operator new(`std::size_t`, `std::align_val_t`). But if work with compiler and third-party library that don't fully adopt C++17 alignment guarantees or  do not respect the alignment requirements of Eigen types, the macro ensures compatibility.
