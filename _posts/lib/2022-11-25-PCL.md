---
layout: post
title:  "PCLå­¦ä¹ "
date:   2025-02-07 23:15:06 +0800
categories: [Tech]
excerpt: å¸¸ç”¨PCLå‡½æ•°ï¼›PCLçš„æ•°æ®ç»“æ„ï¼›ç­‰ç­‰ã€‚
tags:
  - PCL
  - C++
---

è¿™ç¯‡æ–‡ç« æ•´ç†äº†å¸¸ç”¨PCLå‡½æ•°(ç”¨é€”ã€å‚æ•°çš„æ„ä¹‰ï¼Œå¿…è¦æ—¶ä¹Ÿä¼šåˆ—å‡ºè¯¥å‡½æ•°æ‰€åœ¨çš„å¤´æ–‡ä»¶)ä»¥åŠä¸€äº›å…¶å®ƒå…³äºPCLåº“çš„çŸ¥è¯†ã€‚

# Empirical Observation

sort by alphabet.
### pcl::Octree
##### adoptBoundingBoxToPoint
This function can adjust bounding box even the box has been defined manually.
##### defineBoundingBox
`pcl::Octree::OctreePointCloud::defineBoundingBox`: input bounding box will be used as initial bounding box first. Then the box will be adjusted to a cube. The adjusted bounding box always is different with the initial bounding box.
##### 

### pcl::ConcaveHull

```C++
#include <pcl/surface/concave_hull.h>
int main (int argc, char** argv)
{
  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>), cloud_hull(new pcl::PointCloud<pcl::PointXYZ>);
  // load file to cloud
  pcl::ConcaveHull<pcl::PointXYZ> chull;
  chull.setInputCloud (cloud);
  chull.setAlpha (0.1); // è®¾ç½®alphaå€¼ï¼Œæ ¹æ®éœ€è¦è°ƒæ•´ã€‚å†³å®šå‡¹åŒ…è®¡ç®—çš„ç´§å¯†ç¨‹åº¦ï¼šè¾ƒå°çš„å€¼ä¼šç”Ÿæˆæ›´ç´§å¯†ã€æ›´è¯¦ç»†çš„è½®å»“ï¼Œä½†å¯èƒ½ä¼šå¯¼è‡´æ›´å¤šçš„å°æ´å’Œç¢ç‰‡ï¼›è¾ƒå¤§çš„å€¼ä¼šç”Ÿæˆæ›´å¹³æ»‘çš„è½®å»“ã€‚
  chull.reconstruct (*cloud_hull);
}
```

# ä¸€ã€åŸºç¡€çŸ¥è¯†

#### 1. data()



#### 2

  
# chapter 2 octree

### getIntersectedVoxelCenters
```C++
pcl::octree::OctreePointCloudSearch::getIntersectedVoxelCenters(Eigen::Vector3f origin,
                                                                Eigen::Vector3f direction,
                                                                AlignedPointTVector& voxel_center_list,
                                                                int max_voxel_count);
```
whether normalize `direction` can influence the result.
1. Best Case
$ğ‘‚(logâ¡(ğ‘))$ In the ideal case, the octree is well-balanced, and the ray intersects only a small number of voxels, minimizing traversal.
2. Average Case
$ğ‘‚(ğ‘˜+log(ğ‘))$ Where ğ‘˜ is the number of voxels intersected by the ray. Traversing the octree to find the ray's starting position is $ğ‘‚(logâ¡(ğ‘))$, and processing intersected voxels depends on ğ‘˜.
3. Worst Case
$ğ‘‚(ğ‘˜)$ If the ray intersects a large number of voxels (e.g., when the ray passes through the entire octree), the complexity is proportional to the number of intersected voxels.


# ä¸‰ã€ä½å§¿å˜æ¢
```C++
#include <pcl/common/transforms.h> //ä¸»è¦å†…å®¹ä¸ºï¼šè¡¨ç¤ºä½å§¿çš„å‡ ç§æ–¹æ³•ä¹‹é—´çš„è½¬æ¢
//cloud_inå’Œcloud_outä¸º::Ptrç‚¹äº‘æŒ‡é’ˆ; Matrix4f=Affine3f
void pcl::transformPointCloud(const *cloud_in, *cloud_out, const Eigen::Matrix4f  & transform)
```

##### 2. pcl/common/eigen.h
> 4Ã—4å˜æ¢çŸ©é˜µ transformation Eigen::Affine3f ä»¿å°„çŸ©é˜µ --> poså’Œrpy ä½ç½®å’Œè§’åº¦ 6Dä½å§¿ ï¼›è¾“å…¥å’Œè¾“å‡ºå‚æ•°ä¸ºfloat

```C++
#include <pcl/common/eigen.h>

// ç²¾åº¦å¯èƒ½å­˜åœ¨é—®é¢˜
pcl::getTranslationAndEulerAngles(imuOdomAffineLast, x, y, z, roll, pitch, yaw);

// è¾“å…¥å’Œè¾“å‡ºå‚æ•°ä¸ºfloat
Eigen::Affine3f lastPoseInMapAff = pcl::getTransformation(x, y, z, roll, pitch, yaw);
```
# å››ã€åŒ¹é…å’Œé…å‡†

### 1. ndt.h
```C++
setTransformationEpsilon(ndt_epsilon_); // the transformation epsilon in order for an optimization to be considered as having converged to the final solution.
setStepSize(ndt_step_size_); // Set the newton line search maximum step length.
setResolution(ndt_resolution_); // Set the voxel grid resolution.
getFitnessScore	(	double 	max_range = std::numeric_limits<double>::max()	); // Obtain the Euclidean fitness score (e.g., mean of squared distances from the source to the target)
```


### 2. pcl/kdtree/kdtree_flann.h
```C++
#include <pcl/kdtree/kdtree_flann.h>
// max_nn: num of returned points, if max_nn==0, return all.
kdtreeSurroundingKeyPoses->radiusSearch(point, radius, k_indices, k_sqr_distances,	max_nn);

pcl::moveFromROSMsg(currentCloudMsg, *laserCloudIn);
```

### 3. pcl/registration/icp.h
```C++
#include <pcl/registration/icp.h>
pcl::IterativeClosestPoint<pcl::PointXYZ, pcl::PointXYZ> icp;
pcl::PointCloud<pcl::PointXYZ>::Ptr loopSourceCorner;
icp.setInputSource(loopSourceCorner); //æ³¨æ„è¾“å…¥çš„ç‚¹äº‘çš„æ•°æ®ç±»å‹ä¸ºPtr
```
## äº”ã€æ–‡ä»¶å¤„ç†

##### 1. åŠ è½½æ–‡ä»¶


```C++
#include <pcl/io/pcd_io.h>
//temFilePathåŒ…å«æ–‡ä»¶åå’Œåç¼€;thisCornerCloudä¸º::Ptrç‚¹äº‘æŒ‡é’ˆ;
pcl::io::loadPCDFile(temFilePath, *thisCornerCloud);

```


```C++

```

##### 2

## other
##### 1. 
You can use the following code to print out the fields of your registered point type and verify the order:
```C++
template <typename PointT>
void printPointTypeFields() {
    std::cout << "Fields in the point type:\n";
    for (const auto& field : pcl::traits::fieldList<PointT>::type::fields) {
        std::cout << "  " << field.name << "\n";
    }
}
```

##### 2. pcl::octree
the returned value of `pcl::Octree::getIntersectedVoxels` is not guaranteed to be sorted by default.

##### 3. 
leaf_begin(): breadth-first
leaf_depth_begin(): depth-first manner 

## æœ«ã€Q&A
##### 1. 
è¿è¡Œ`pcl_viewer`æ—¶æç¤ºé”™è¯¯`segment fault(core dump)`ã€‚å¯èƒ½æ˜¯å› ä¸ºé©±åŠ¨å®‰è£…æœ‰é—®é¢˜ï¼Œæˆ–è€…pclçš„ç‰ˆæœ¬ä¸é€‚é…ã€‚

##### 2. 
code below is used to define and register a point type to PCL.
```C++
#include <pcl/point_types.h>

namespace custom_pcl
{
  struct MyCustomPoint
  {
    PCL_ADD_POINT4D;  // This macro adds padding for alignment and the XYZ fields
    int id;           // Add the custom field `id`
    EIGEN_MAKE_ALIGNED_OPERATOR_NEW  // Ensure proper alignment
  };
}

POINT_CLOUD_REGISTER_POINT_STRUCT(
  custom_pcl::MyCustomPoint,  // Fully qualified name of the struct
  (float, x, x)               // Mapping: type, field name in struct, field name in PCL
  (float, y, y)
  (float, z, z)
  (int, id, id)               // Include the new `id` field
)
```
Note that the `POINT_CLOUD_REGISTER_POINT_STRUCT` macro must be placed in the global namespace. You cannot place it inside a namespace because the macro relies on global templates and compile-time mechanisms that PCL expects in the global scope. However, you can still define your custom point type within a namespace. Only the macro itself has to remain in the global scope.

##### 3.
Define a point type from existing point type in PCL
```C++
namespace custom_pcl
{
  struct EIGEN_ALIGN16 MyCustomPoint : public pcl::PointXYZINormal
  {
    int id;  // Additional field
    EIGEN_MAKE_ALIGNED_OPERATOR_NEW  // Ensure proper memory alignment
  };
}

POINT_CLOUD_REGISTER_POINT_STRUCT(
  custom_pcl::MyCustomPoint,
  (float, x, x)
  (float, y, y)
  (float, z, z)
  (float, intensity, intensity)
  (float, normal_x, normal_x)
  (float, normal_y, normal_y)
  (float, normal_z, normal_z)
  (float, curvature, curvature)
  (int, id, id)
)
```
Then I got a warning.
```bash
warning: offsetof within non-standard-layout type 'sinoslam::Pointid' is conditionally-supported [-Winvalid-offsetof]
```
Standard Layout Requirements:
1. A standard-layout type is one where all non-static data members are laid out in a well-defined order in memory, and there is no ambiguity due to inheritance.
2. Adding new fields to a derived class makes the layout non-standard because the base class may already contain its own fields, making offsets potentially ambiguous.

##### 4. 
code below
```C++
template <class PointT>
bool calculateNormal(const pcl::PointCloud<PointT>::Ptr &cloud, Eigen::Vector3f &normal) {}
```
I got an error during compilation:
```bash
error : need 'typename' before 'pcl::PointCloud<PointT>::Ptr' because 'pcl::PointCloud<PointT>' is a dependent bool calculateNormal(const pcl::PointCloud<PointT>::Ptr &cloud, Eigen::Vector3f &normal)
```
The error arises because in a templated function, PointT is a dependent type, and the compiler needs explicit help to identify pcl::PointCloud<PointT>::Ptr as a type. To fix this, you must use the typename keyword to specify that it is a type. Here's the corrected code:
```C++
template <typename PointT>
bool calculateNormal(const typename pcl::PointCloud<PointT>::Ptr &cloud, Eigen::Vector3f &normal) {}
```
In fact, the corrected code can't be compiled successfully. Because

##### 5
```bash
octree_search.hpp : 396 : 46 : error : 'const struct custom::Pointid' has no member named 'getVector3fMap' return (point_a.getVector3fMap() - point_b.getVector3fMap()).squaredNorm();
```
The error indicates that the structure custom::Pointid does not have a member function or attribute named getVector3fMap. This function is a part of the PCL library for points that are derived from pcl::PointXYZ or similar types. Your custom Pointid struct likely does not inherit from a pcl::PointXYZ-like structure or does not implement this function.

##### 6
The macro `EIGEN_MAKE_ALIGNED_OPERATOR_NEW` and `EIGEN_ALIGN16` is not strictly necessary for C++17 in most cases, because C++17 introduced guarantees for aligned memory allocation through new alignment-aware operators like operator new(`std::size_t`, `std::align_val_t`). But if work with compiler and third-party library that don't fully adopt C++17 alignment guarantees or  do not respect the alignment requirements of Eigen types, the macro ensures compatibility.